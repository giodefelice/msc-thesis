\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{braket}
\usepackage[toc,page]{appendix}

%%%THEOREM (ETC) ENVIRONMENTS
\newtheorem{definition}{Definition}
\newtheorem{claim}{Claim}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}
\newtheorem{problem}{Problem}
\newtheorem{idea}{Idea} 

\usepackage{proof}
\newtheorem{theorem}{Theorem}

\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}

\newenvironment{proof}[1][Proof]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}]}{\begin{flushright}$\blacksquare$\end{flushright} \end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newcommand{\cat}{\mathcal{C}}
\newcommand{\Tau}{\mathrm{T}}
\newcommand{\ham}{\mathcal{H}}
\title{Hopf Algebras in Quantum Computation}
\author{Giovanni de Felice}
\date{April 2017}

%%%TIKZ:
\usepackage{tikz,pgfplots}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{trees, patterns}
\usetikzlibrary{positioning}
\usepackage{tikz,ifthen,calc}
\usepackage{tkz-euclide}
\usetikzlibrary{shapes,snakes}
\usetikzlibrary{calc,intersections, fit, knots, hobby, positioning, patterns}
\usepackage{braids}

%%%categorical diagrams:
\tikzset{
	buffer/.style={
		draw,
		shape border rotate=180,
		regular polygon,
		regular polygon sides=3,
		node distance=2cm,
		minimum height=4em
	}
}
\tikzstyle{arr}=[markings,mark=at position 0.5 with {\arrow{<}}]
%%%HOPF ALGEBRAS:
\newcommand{\mult}{
	\begin{tikzpicture}[scale=0.2, black/.style={scale=0.5,draw,shape=circle,fill=black}]
	\node[black] (0) at (0, 0) {};
	\draw (1,-1) to (0);
	\draw (-1,-1) to (0);
	\draw (0) to (0,1);
	\end{tikzpicture}
}
\newcommand{\unit}{
	\begin{tikzpicture}[scale=0.2, black/.style={scale=0.5,draw,shape=circle,fill=black}]
	\node[black] (0) at (0, 0) {};
	\draw (0) to (0,1);
	\end{tikzpicture}
}
\newcommand{\comult}{
	\begin{tikzpicture}[scale=0.2, black/.style={scale=0.5,draw,shape=circle,fill=white}]
	\node[black] (0) at (0, 0) {};
	\draw (1,1) to (0);
	\draw (-1,1) to (0);
	\draw (0) to (0,-1);
	\end{tikzpicture}
}

\newcommand{\counit}{
	\begin{tikzpicture}[scale=0.2, black/.style={scale=0.5,draw,shape=circle,fill=white}]
	\node[black] (0) at (0, 0) {};
	\draw (0) to (0,-1);
	\end{tikzpicture}
}

\newcommand{\antipode}{
	\begin{tikzpicture}[scale=0.2, black/.style={scale=0.5,draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node[scale=0.5, black] (0) at (0, 0) {$S$};
	\draw (0) to (0,-1);
	\draw (0) to (0,1);
	\end{tikzpicture}
}

\newcommand{\associativity}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\node[scale=0.5,draw,circle,fill=black] (0) at (0,0.5) {};
	\node[scale=0.5,draw,circle,fill=black] (1) at (0.5,0) {};
	\draw (0) to (1);
	\draw (-1,-0.5) to (0);
	\draw (0,-0.5) to (1);
	\draw (1,-0.5) to (1);
	\draw (0) to (0,1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\node[scale=0.5,draw,circle,fill=black] (0) at (0.5,0.5) {};
	\node[scale=0.5,draw,circle,fill=black] (1) at (0,0) {};
	\draw (0) to (1);
	\draw (-0.5,-0.5) to (1);
	\draw (0.5,-0.5) to (1);
	\draw (1.5,-0.5) to (0);
	\draw (0) to (0.5,1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
}
\newcommand{\unitlaw}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\node[scale=0.5,draw,circle,fill=black] (0) at (0,0.5) {};
	\node[scale=0.5,draw,circle,fill=black] (1) at (0.5,0) {};
	\draw (0) to (1);
	\draw (-0.5,0) to (0);
	\draw (0) to (0,1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\draw (0,0) to (0,1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\node[scale=0.5,draw,circle,fill=black] (0) at (0,0.5) {};
	\node[scale=0.5,draw,circle,fill=black] (1) at (-0.5,0) {};
	\draw (0) to (1);
	\draw (0.5,0) to (0);
	\draw (0) to (0,1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
}
\newcommand{\coassociativity}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\node[scale=0.5,draw,circle,fill=white] (0) at (0,-0.5) {};
	\node[scale=0.5,draw,circle,fill=white] (1) at (0.5,0) {};
	\draw (0) to (1);
	\draw (-1,0.5) to (0);
	\draw (0,0.5) to (1);
	\draw (1,0.5) to (1);
	\draw (0) to (0,-1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\node[scale=0.5,draw,circle,fill=white] (0) at (0.5,-0.5) {};
	\node[scale=0.5,draw,circle,fill=white] (1) at (0,0) {};
	\draw (0) to (1);
	\draw (-0.5,0.5) to (1);
	\draw (0.5,0.5) to (1);
	\draw (1.5,0.5) to (0);
	\draw (0) to (0.5,-1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
}
\newcommand{\counitlaw}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\node[scale=0.5,draw,circle,fill=white] (0) at (0,-0.5) {};
	\node[scale=0.5,draw,circle,fill=white] (1) at (0.5,0) {};
	\draw (0) to (1);
	\draw (-0.5,0) to (0);
	\draw (0) to (0,-1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\draw (0,0) to (0,1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\node[scale=0.5,draw,circle,fill=white] (0) at (0,-0.5) {};
	\node[scale=0.5,draw,circle,fill=white] (1) at (-0.5,0) {};
	\draw (0) to (1);
	\draw (0.5,0) to (0);
	\draw (0) to (0,-1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
}

\newcommand{\bialgebralaw}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\node[scale=0.5,draw,circle,fill=white] (0) at (0,0) {};
	\node[scale=0.5,draw,circle,fill=white] (1) at (1,0) {};
	\node[scale=0.5,draw,circle,fill=black] (2) at (0,1) {};
	\node[scale=0.5,draw,circle,fill=black] (3) at (1,1) {};
	\draw (0) to (2);
	\draw (0) to (3);
	\draw (1) to (2);
	\draw (1) to (3);
	\draw (0,-0.5) to (0);
	\draw (1,-0.5) to (1);
	\draw (0,1.5) to (2);
	\draw (1,1.5) to (3);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8]
	\node[scale=0.5,draw,circle,fill=black] (0) at (0.5,0) {};
	\node[scale=0.5,draw,circle,fill=white] (1) at (0.5,1) {};
	\draw (0) to (1);
	\draw (0,-0.5) to (0);
	\draw (1,-0.5) to (0);
	\draw (0,1.5) to (1);
	\draw (1,1.5) to (1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
}
\newcommand{\copylaw}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7, squr/.style={scale=0.5,draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={scale=0.5,draw,shape=circle,fill=black}, whit/.style={scale=0.5,draw,shape=circle,fill=white}]
	\node[black] (0) at (0, 0) {};
	\node[whit] (1) at  (0, 0.8) {};
	\draw (0) to (1);
	\draw (1) to (0.5,1.5);
	\draw (1) to (-0.5,1.5);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7, black/.style={scale=0.5,draw,shape=circle,fill=black}]
	\node[black] (0) at (0,0) {};
	\node[black] (1) at (1,0) {};
	\draw (0) to (0,1);
	\draw (1) to (1,1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
}
\newcommand{\cocopylaw}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7, squr/.style={scale=0.5,draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={scale=0.5,draw,shape=circle,fill=black}, whit/.style={scale=0.5,draw,shape=circle,fill=white}]
	\node[whit] (0) at (0, 0) {};
	\node[black] (1) at  (0, -0.8) {};
	\draw (0) to (1);
	\draw (1) to (0.5,-1.5);
	\draw (1) to (-0.5,-1.5);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7, black/.style={scale=0.5,draw,shape=circle,fill=white}]
	\node[black] (0) at (0,0) {};
	\node[black] (1) at (1,0) {};
	\draw (0) to (0,-1);
	\draw (1) to (1,-1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
}
\newcommand{\hopflaw}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8, squr/.style={scale=0.5,draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node[scale=0.5,draw,circle,fill=white] (0) at (0,0) {};
	\node[scale=0.5,draw,circle,fill=black] (1) at (0,1) {};
	\node[squr] (2) at (0.5,0.5) {$S$};
	\draw[bend left=80] (0) to (1);
	\draw[bend right] (0) to (2);
	\draw[bend right] (2) to (1);
	\draw (0,-0.5) to (0);
	\draw (0,1.5) to (1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node[scale=0.5,draw,circle,fill=white] (0) at (0,0) {};
	\node[scale=0.5,draw,circle,fill=black] (1) at (0,1) {};
	\draw (0,-0.5) to (0);
	\draw (0,1.5) to (1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8, squr/.style={scale=0.5,draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node[scale=0.5,draw,circle,fill=white] (0) at (0,0) {};
	\node[scale=0.5,draw,circle,fill=black] (1) at (0,1) {};
	\node[squr] (2) at (-0.5,0.5) {$S$};
	\draw[bend right=80] (0) to (1);
	\draw[bend left] (0) to (2);
	\draw[bend left] (2) to (1);
	\draw (0,-0.5) to (0);
	\draw (0,1.5) to (1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
}
\newcommand{\modulelaw}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={scale=0.5,draw,shape=circle,fill=black}]
	\node (0) at (0, -2.2) {};
	\node[squr] (1) at (0, 0) {};
	\node (2) at (0, 1) {};
	\node[black] (3) at (-0.8, -1) {};
	\draw (0) to (1);
	\draw (1) to (2);
	\draw[bend left] (3) to (1);
	\draw (-1.3, -2) to (3);
	\draw (-0.3, -2) to (3);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,shape=circle,fill=black}]
	\node (0) at (0, -2.2) {};
	\node[squr] (1) at (0, 0) {};
	\node (2) at (0, 1) {};
	\node[squr] (3) at (0, -1) {};
	\draw (0) to (3);
	\draw (3) to (1);
	\draw (1) to (2);
	\draw (3) to (1);
	\draw[bend left] (-1.3, -2) to (1);
	\draw[bend left] (-0.5, -2) to (3);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
}
\newcommand{\comodulelaw}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={scale=0.5,draw,shape=circle,fill=white}]
	\node (0) at (0, 2.2) {};
	\node[squr] (1) at (0, 0) {};
	\node (2) at (0, -2) {};
	\node[black] (3) at (-0.8, 1) {};
	\draw (0) to (1);
	\draw (1) to (2);
	\draw[bend right] (3) to (1);
	\draw (-1.3, 2) to (3);
	\draw (-0.3, 2) to (3);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,shape=circle,fill=black}]
	\node (0) at (0, 2.2) {};
	\node[squr] (1) at (0, 0) {};
	\node (2) at (0, -1) {};
	\node[squr] (3) at (0, 1) {};
	\draw (0) to (3);
	\draw (3) to (1);
	\draw (1) to (2);
	\draw (3) to (1);
	\draw[bend right] (-1.3, 2) to (1);
	\draw[bend right] (-0.5, 2) to (3);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
}
\newcommand{\intertwinerlaw}{
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (0, -2.2) {$V$};
	\node[squr] (1) at (0, 0) {};
	\node (2) at (0, 1.2) {$W$};
	\node[scale=0.8,draw,circle] (3) at (0, -1) {$f$};
	\draw (0) to (3);
	\draw (3) to (1);
	\draw (1) to (2);
	\draw (3) to (1);
	\draw[bend left] (-1.5, -2) to (1);
	\end{tikzpicture}	
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node (0) at (0, -2.2) {$V$};
	\node[scale=0.8,draw,circle] (1) at (0, 0) {$f$};
	\node (2) at (0, 1.2) {$W$};
	\node[squr] (3) at (0, -1) {};
	\draw (0) to (3);
	\draw (3) to (1);
	\draw (1) to (2);
	\draw (3) to (1);
	\draw[bend left] (-1, -2) to (3);
	\end{tikzpicture}	
	\end{gathered}
	\end{equation}
}
\newcommand{\symAB}{
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\node (0) at (-0.5, -0.7) {$A$};
	\node (0) at (-0.5, 0.7) {$B$};
	\node (1) at (0.5, -0.7) {$B$};
	\node (1) at (0.5, 0.7) {$A$};
	\draw [->] (-0.5, -0.5) to (0.5, 0.5);
	\draw [->] (0.5, -0.5) to (-0.5, 0.5);
	\end{tikzpicture}
}

\newcommand{\symequation}{
	\begin{equation*}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7]
	\node (0) at (-1, -1.2) {$A$};
	\node (0) at (0, -1.2) {$B$};
	\draw [->] (-1, -1)--(0,0)--(-1,1);
	\draw [->] (0, -1)--(-1,0)--(0,1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7]
	\node (0) at (-0.8, -1.2) {$A$};
	\node (0) at (0, -1.2) {$B$};
	\draw [->] (-0.8, -1)--(-0.8,1);
	\draw [->] (0, -1)--(0,1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation*}
}

\newcommand{\cupA}{	
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{<}}}]
	\node (0) at (0, 0.2) {$A$};
	\node (1) at (1, 0.2) {$A^*$};
	\draw [bend right=90, looseness=1.5, postaction=decorate] (0,0) to (1,0);
	\end{tikzpicture}}

\newcommand{\capA}{	
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{<}}}]
	\node (0) at (0, -0.2) {$A$};
	\node (1) at (1, -0.2) {$A^*$};
	\draw [bend left=90, looseness=1.5, postaction=decorate] (0,0) to (1,0);
	\end{tikzpicture}}

\newcommand{\snake}{
	\begin{equation*}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7,decoration={markings,mark=at position 0.5 with {\arrow{<}}}]
	\node (0) at (0, 0.7) {$A$};
	\node (4) at (2, -0.7){$A$};
	\draw [bend right=90, looseness=1.5, postaction=decorate] (0, 0) to (1, 0);
	\draw [bend left=90, looseness=1.5, postaction=decorate] (1, 0) to (2, 0);
	\draw [postaction=decorate] (2, 0) to (2, -0.5);
	\draw [postaction=decorate] (0, 0.5) to (0, 0);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7,decoration={markings,mark=at position 0.5 with {\arrow{<}}}]
	\node (0) at (0, 0.7) {$A$};
	\node (4) at (0, -0.7){$A$};
	\draw [postaction=decorate] (0, 0.5) to (0, -0.5);
	\end{tikzpicture}
	\end{gathered}
	\end{equation*}}

\newcommand{\snakestar}{
	\begin{equation*}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7,decoration={markings,mark=at position 0.5 with {\arrow{<}}}]
	\node (0) at (0, -0.7) {$A^*$};
	\node (4) at (2, 0.7){$A^*$};
	\draw [bend left=90, looseness=1.5, postaction=decorate] (0, 0) to (1, 0);
	\draw [bend right=90, looseness=1.5, postaction=decorate] (1, 0) to (2, 0);
	\draw [postaction=decorate] (2, 0) to (2, 0.5);
	\draw [postaction=decorate] (0, -0.5) to (0, 0);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7,decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\node (0) at (0, 0.7) {$A^*$};
	\node (4) at (0, -0.7){$A^*$};
	\draw [postaction=decorate] (0, 0.5) to (0, -0.5);
	\end{tikzpicture}
	\end{gathered}
	\end{equation*}
}

\newcommand{\fusionijk}{
	\begin{tikzpicture}[scale=0.6,decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\node (0) at (-0.9, -0.3) {$i$};
	\node (1) at (0.9, -0.3) {$j$};
	\node (2) at (0.4, 0.6) {$k$};
	\draw [postaction=decorate] (-1, -1) to(0,0);
	\draw [postaction=decorate] (1,-1) to (0,0);
	\draw [postaction=decorate] (0,0) to (0,1.3);
	\end{tikzpicture}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
	
\section{The Algebra of Anyons}
In this section we introduce the physics of Anyons and use the framework developed in the first section to define categorical models for theories of these particles. For an introduction to the physics of anyons consider the foundational paper \cite{Kitaev06} or Simon's notes \cite{Simon16}, for a categorical presentation \cite{Panangaden11} and for a thorough survey of the mathematical aspects of anyons \cite{Rowell17}.\\
In the first section we introduce the physics and make the link with braided fusion categories, in the second part of we will develop the categorical formalism and the third part is dedicated to one result where quantification and categorical constructions play an important role.\\~\\
To understand how anyons arise physically, let us consider $n$ indistinguishable particles evolving in space. The quantum amplitude for a space-time evolution of the system will depend on the topology of the particle word-lines and not on the detailed geometry. This means that isotopic space-time evolution will yield the same amplitude.\\
To formalize the situation suppose we have $n$ indistinguishable particles in $D$ dimensions, the configuration space can be written as:
$$ \mathrm{C}=(\mathbb{R}^{nD}-\Delta)/S_n$$
Where $\Delta$ is the space of coincidences (where at least two of the $n$ particles occupy the same position in $\mathbb{R}^D$). We are quotienting the space by $S_n$ to account for the indistinguishability of the particles (i.e we do not care about the order of the $n$ coordinates in $D$ dimensions). 
Let us fix the starting and endpoint in the configuration space, the space of paths from starting to endpoint $\mathrm{C}$ divides into topologically distinct classes, described by the fundamental group $\pi_1(\mathrm{C})$. These classes account for the different possible exchange statistics of the particles.\\
We can then describe the evolution of the wave function for the system via unitary transformations induced from the element of the fundamental group corresponding to particles word-lines. In mathematical terms this corresponds to a representation of $\pi_1(\mathrm{C})$. \\
If space-time has $D=3+1$ dimensions, the topological class of paths is completely determined by the corresponding permutation of the particles, because there are no knots in $4$ dimensions. Therefore the evolution of the system under particle exchanges will be described by a representation of the symmetric group $S_n$.
In $2+1$ dimensions we have more exotic behaviour, as the paths in configuration space can braid. The time evolution of the wave function is then described by a representation of the braid group on $n$ strands, denoted $B_n$.
\begin{definition}[Braid group]
	The braid group on $n$ strands $B_n$ is the group generated by $\{ \sigma_i: i=1,..,n-1\}$  satisfying the following relations:
	\begin{itemize}
		\item $\sigma_i \sigma_j = \sigma_j \sigma_i$ for $i+1 < j$
		\item $ \sigma_i \sigma_{i+1} \sigma_i = \sigma_{i+1} \sigma_i \sigma_{i+1}$ for $1 < i < n$.
	\end{itemize}
	 The second relation is called Yang-Baxter equation and can be drawn as follows:
\begin{equation}
\begin{gathered}
\begin{tikzpicture}[scale=0.6]
\node (0) at (0.5,0.5) {};
\node (1) at (-0.1,-0.4) {$i-1$};
\node (2) at (1,-0.4) {$i$};
\node (3) at (2.1,-0.4) {$i+1$};
\node (4) at (1.5,1.5) {};
\node (5) at (0.5,2.5) {};
\draw (0,0)--(0)--(1,1)--(4)--(2,2)--(2,3);
\draw (1,0)--(0,1)--(0,2)--(5)--(1,3);
\draw (2,0)--(2,1)--(0,3);
\end{tikzpicture}
\end{gathered}
\, = \,
\begin{gathered}
\begin{tikzpicture}[scale=0.6]
\node (0) at (1.5,0.5) {};
\node (1) at (-0.1,-0.4) {$i-1$};
\node (2) at (1,-0.4) {$i$};
\node (3) at (2.1,-0.4) {$i+1$};
\node (4) at (0.5,1.5) {};
\node (5) at (1.5,2.5) {};
\draw (2,0)--(1,1)--(0,2)--(0,3);
\draw (1,0)--(0)--(2,1)--(2,2)--(1,3);
\draw (0,0)--(0,1)--(4)--(5)--(2,3);
\end{tikzpicture}
\end{gathered}
\end{equation}
\end{definition}

\begin{itemize}
	\item Abelian case
\end{itemize}
We say the system is abelian if the wave function lives in a one-dimensional representation of the group of paths in configuration space. In $3+1$ dimensions, this means we have to consider the one-dimensional representations of $S_N$. Note that there are only two possibilities (namely the trivial and the sign representations) corresponding to the two possible types of particle statistics in $3+1$ dimensions (Bose and Fermi statistics respectively).
In $2+1$ dimensions we have many more possibilities as the evolution of the wave function will be described by a one-dimensional representation of the braid group $B_N$. There are infinitely many one dimensional representations of the braid group connecting the fermions and bosons case. These are described by a single parameter $\theta$. Only one parameter because using Yang-Baxter we can show that all $N$ phases have to be the same, also can show $\theta$ has to be a fraction from physical considerations. We obtain abelian anyons.\\
\begin{itemize}
	\item Non-abelian case
\end{itemize}
In the non-abelian case, the wave function lives in a higher-dimensional representation of In $3+1$ dimensions we don't get anything more than bosons and fermions if we also want to consider creation, annihilation (splitting, fusion) of particles (Doplicher-Roberts theorem). 
In $2+1$ dimensions we obtain degeneracy, non-abelian anyons, braidings give all unitaries.\\~\\
In the previous section, we only considered groups of symmetries of a Hamiltonian. In order take topological symmetries of a system into account, we need the more general framework of Hopf Algebras. In particular, as those symmetries arise from braids, we need quasitriangular hopf algebras (or quantum groups) to treat all symmetries on the same level. We will see that the universal $R$-matrix plays an important role in the description of topological dependencies.

\subsection{Models of anyons}
We want to construct a category $\cat$ that models the behaviour of anyons. Ojects of $\cat$ will correspond to quantum systems and morphisms to their possible evolutions, or to the processes we can perform on them.\\
Let us first set a finite set of labels $I = \{a,b,c...\}$ of distinct particle types, these will be objects of $\cat$. In our theory we must be able to consider many particles at the same time, so $\cat$ must be monoidal \cite{Coecke17}. The unit of the tensor $\mathbf{1}$ corresponds to the vacuum particle type (or "no-particle") and must be within our labels. So for the moment our theory is a monoidal category $\mathcal{C}$ and we can already use the diagrammatic language. A particle of type $a$ evolving trivially in time is denoted:
\begin{center}
\begin{tikzpicture}[scale=0.7, decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\node (a) at (0.3,0) {$a$};
	\draw [postaction = decorate] (0,-1) to (0,1);
\end{tikzpicture}
\end{center}
Where we have adopted the convention that time flows upwards.\\
Two particles of types $a$ and $b$ can fuse to a third particle of type $c$. So we have fusion morphisms:
\begin{center}
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\node (a) at (-0.5,-0.5) {$a$};
	\node (b) at (0.5,-0.5) {$b$};
	\node (c) at (0.3,0.5) {$c$};
	\draw [postaction = decorate] (-0.5,-1) to (0,0);
	\draw [postaction = decorate] (0.5,-1) to (0,0);
	\draw [postaction = decorate] (0,0) to (0,1);
	\end{tikzpicture}
\end{center}
Similarly a particle $c$ can split to give two particles $a$ and $b$. And $\cat$ contains splitting morphism:
\begin{center}
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{<}}}]
	\node (a) at (-0.5,0.5) {$a$};
	\node (b) at (0.5,0.5) {$b$};
	\node (c) at (0.3,-0.5) {$c$};
	\draw [postaction = decorate] (-0.5,1) to (0,0);
	\draw [postaction = decorate] (0.5,1) to (0,0);
	\draw [postaction = decorate] (0,0) to (0,-1);
	\end{tikzpicture}
\end{center}
Any particle $a$ in quantum physics comes with its antiparticle $a^*$ which we can picture as a particle of type $a$ travelling backwards in time.
\begin{center}
	\begin{tikzpicture}[scale=0.7, decoration={markings,mark=at position 0.5 with {\arrow{<}}}]
	\node (a) at (0.3,0) {$a$};
	\draw [postaction = decorate] (0,-1) to (0,1);
	\end{tikzpicture}
\end{center}
It has the property of fusing to the vacuum when it encounters $a$. Dually the vacuum can yield a particle-antiparticle pair, so we have cups and caps morphisms
\begin{center}
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{<}}}]
	\draw [bend right=90, looseness=1.6, postaction = decorate] (-0.5,0) to (0.5,0);
	\end{tikzpicture}
	\quad
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{<}}}]
	\draw [bend left=90, looseness=1.6, postaction = decorate] (-0.5,0) to (0.5,0);
	\end{tikzpicture}
	\quad
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\draw [bend right=90, looseness=1.6, postaction = decorate] (-0.5,0) to (0.5,0);
	\end{tikzpicture}
	\quad
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\draw [bend left=90, looseness=1.6, postaction = decorate] (-0.5,0) to (0.5,0);
	\end{tikzpicture}
\end{center}
Categorically this corresponds to a rigid structure on $\cat$, where we have assumed that every object has two-sided duals. We will also assume the category is well behaved: it is spherical and $1^*=1$. This allows us to define the quantum numbers for each particle type $a$ to be the following scalar:
\begin{equation}
	d_a := tr(id_a) =
	\begin{gathered}
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{<}}}]
	\node (a) at (0.7,0) {$a$};
	\draw [bend left=90, looseness=1.6, postaction = decorate] (0.5,0) to (-0.5,0);
	\draw [bend left=90, looseness=1.6, postaction = decorate] (-0.5,0) to (0.5,0);
	\end{tikzpicture}
	\end{gathered}
\end{equation}
At this point we need to linearise the theory to take superpositions into account. This means we make $\cat$ into a rigid tensor category (see appendix). We have biproducts $\oplus$ to account for superpositions. In order for the fusions to behave well with superpositions we must require that our labels for particle types be simple objects in the category and all objects to decompose as direct sums of simple ones, we say $\cat$ is semisimple. 
\begin{definition}[Fusion category]
	A fusion category is a finite semisimple k-linear tensor category with two sided duals
\end{definition}
At this point, our category $\mathcal{C}$ is a spherical fusion category  and the fusion rules look like this:
\begin{equation}
a \otimes b \simeq \oplus_c N_{ab}^c c
\end{equation}
Where $N_{ab}^c \in \mathbb{N}$. This defines a matrix for any $a$ simple indexed by simple objects $i,j \in I$:
$$(N_a)_{i,j} = N^a_{ij}$$
We can also define the dimension of the theory $\cat$ as the following scalar:
$$dim(\cat) = \sum_{i\in I} d_i^2$$
Given the fusion structure we can define the $F$-matrix which contains the information of the fusions interacting with the  quasi-associativity of the tensor product.
\begin{definition}[F-matrix]
	Given particles types $a$,$b$,$c$ we have two ways of fusing them to obtain particle type $e$, the matrix $F_{abc}^e$ is the change of basis matrix:
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[ decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\node (a) at (-0.5,-0.3) {$a$};
	\node (b) at (0.5,-0.3) {$b$};
	\node (c) at (1.6,-0.3) {$c$};
	\node (d) at (0,0.3) {$d$};
	\node (e) at (0.3,0.7) {$e$};
	\draw [postaction = decorate] (-0.5,-0.5) to (0,0);
	\draw [postaction = decorate] (0.5,-0.5) to (0,0);
	\draw [postaction = decorate] (0,0) to (0.5,0.5);
	\draw [postaction = decorate] (1.5,-0.5) to (0.5,0.5);
	\draw [postaction = decorate] (0.5,0.5) to (0.5,1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\sum_{f\in I} (F_{abc}^e)_{df}
	\begin{gathered}
	\begin{tikzpicture}[ decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\node (a) at (-0.5,-0.3) {$a$};
	\node (b) at (0.5,-0.3) {$b$};
	\node (c) at (1.6,-0.3) {$c$};
	\node (d) at (0.9,0.4) {$f$};
	\node (e) at (0.3,0.7) {$e$};
	\draw [postaction = decorate] (1.5,-0.5) to (1,0);
	\draw [postaction = decorate] (0.5,-0.5) to (1,0);
	\draw [postaction = decorate] (1,0) to (0.5,0.5);
	\draw [postaction = decorate] (-0.5,-0.5) to (0.5,0.5);
	\draw [postaction = decorate] (0.5,0.5) to (0.5,1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
\end{definition}
The possibilities for the $F$-matrices are constrained by the pentagon axiom of a monoidal category, it corresponds to a matrix representation of the associators.
We still have one important question to ask to the theory, what happens when the position of two particles is exchanged? To answer this question the theory must have a braided structure and we obtain a braided fusion category. The braided structure determines the long-distance, topological interactions between particles. Braided fusion categories induce representations of the braid group $B_n$, given our discussion at the beginning of this chapter, we see that they are very good candidates for describing theories of anyons. 
The braided structure is captured by the following piece of data:
\begin{definition}[$R$-matrix]
	Given particle types $a$, $b$ and $c$ the matrix $R_{ab}^c$ is defined by:
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\node (a) at (-0.5,-0.6) {$a$};
	\node (b) at (0.5,-0.6) {$b$};
	\node (c) at (0.3,0.5) {$c$};
	\node (0) at (0,-0.5) {};
	\draw [ bend left=50, looseness=1.8] (0) to (0,0);
	\draw [ bend right=50, looseness=1.8] (0,-0.5) to (0,0);
	\draw [postaction = decorate] (-0.5,-1) to (0,-0.5);
	\draw [postaction = decorate] (0.5,-1) to (0);
	\draw [postaction = decorate] (0,0) to (0,1);
	\end{tikzpicture}
	\end{gathered}
	\, = R_{ab}^c \, 
	\begin{gathered}
	\begin{tikzpicture}[decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
	\node (a) at (-0.5,-0.5) {$a$};
	\node (b) at (0.5,-0.5) {$b$};
	\node (c) at (0.3,0.5) {$c$};
	\draw [postaction = decorate] (-0.5,-1) to (0,0);
	\draw [postaction = decorate] (0.5,-1) to (0,0);
	\draw [postaction = decorate] (0,0) to (0,1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
\end{definition}
From the first section we know that sphericality of the theory, interacting with the braided structure yields a ribbon structure. The twist $\theta$ has physical significance, it can be seen as a rotation of the particle and in most interesting cases it will be non-trivial.\\
In the case of abelian anyons, the twist is just a global phase, if we denote by $h_a$ the topological spin of the particle then $\theta_a = e^{2\pi i h_a}$ is the twist factor of $a$. In this scenario, the $R$-matrices are scalars and it is easy to see, using the definition of the twist, that the $R$ coefficients and the twist factors are related by:
$$R_{ab}^c R_{ba}^c = \frac{\theta_c}{\theta_a \theta_b}$$
These coefficients are also constrained by the hexagon axiom of braided monoidal categories. One way to build theories of abelian anyons, is to construct $R$ matrices, twist factors and $F$ matrices which satisfy both hexagon and pentagon axioms. However, these constraints do not fix $R$ and $F$ uniquely. 
\begin{example}[G-graded vector spaces]
	Suppose we start from a set of labels and define the fusions to form a group. $1$ is the identity particle type, for any particle type $a$, $a^*$ will be its inverse. We have defined the skeleton of a spherical fusion category, which we obtain by linearising, i.e taking a fiber functor to $Vect$. We obtain the category $Vec_G$, of $G$ graded vector spaces over $\mathbb{C}$.
	The category $Vec_G$ for $G$ a group is a symmetric spherical fusion category. Linearity and tensor are given by the underlying $Vect$ structure, simple objects $V_g$ are one-dimensional and indexed by elements $g \in G$, duality is proved by using the group inverse and fusions are given by the group multiplication.
	$$V_g \otimes V_h \simeq V_{gh}$$
	In this case both the $F$ and $R$ matrices are trivial.\\
	Tannaka duality hints that this should be a category of representations and indeed it is easy to show that $Vec_G \simeq Rep(Func(G))$ where $Func(G)$ is the function algebra on $G$.\\
	For $G=\mathbb{Z}_2$ we have two irreducible representations $\tau_+$ and $\tau_-$, both one dimensional with the obvious fusion rules given by the cyclic group of order $2$.\\
\end{example}

\begin{proposition}
	If $H$ is a finite dimensional, semisimple, quasitriangular Hopf algebra, then $Rep(H)$ is a braided fusion category and $dim(Rep(H))=dim(H)$.
\end{proposition}
\begin{proof}
	The proof is given by [find citation]
\end{proof}
This proposition gives us a way of building theories of anyons from hopf algebras.\\
The first example that comes to mind is that of a group algebra $\mathbb{C}G$. So let us suppose the theory is described by the category $RepG$. 
First consider the object $V= \mathbb{C}G$. It is known that $\mathbb{C}G \simeq \oplus_{i \in I} X_i \otimes X_i^*$. Simple objects $X_i$ correspond to particle types so $V$ can be seen as the completely mixed state. This object (i.e the vector space with it's $G$-action) carries all the information of the theory (remember tannaka duality) and indeed we could study the theory by just considering this algebra. We can think of elements of $G$ as particle subtypes, particle types correspond to conjugacy classes, a state $v \in V$ is a superposition of particle subtypes. The action of $G$ permutes the basis vectors, and precisely corresponds to fusion. So acting with $g \in G$ on a state $v \in V$ corresponds to fusing a particle of type $g$ with one that is in a superposition $v$ of particle types.\\
In the case where $G$ is abelian all irreducible representations are one dimensional, each corresponding to an element of the group. So really $Rep(G) \simeq Vec_G$ and behaves exactly like $\mathbb{C}G$ (without distinction between particle types and subtypes). This case is perhaps interesting philosophically as the representations of our symmetries have the same structure as the symmetries themselves [cite majid self-duality]. From a computational perspective it is a trivial situation, as only classical processes can be performed (no entanglement is possible).\\
If $G$ is not abelian we must have a higher dimensional irreducible representation of $G$. So we could obtain more interesting processes but from a topological quantum perspective it remains a trivial case as no computational power can be obtained from the braided structure. This is because $RepG$ is symmetric as we have seen in the first section. Physically, we have seen that symmetric exchange of particles applies to fermions and bosons, from a topological perspective those types of particles can be seen as degenerate cases of anyons.
Groups are therefore not enough to describe interesting anyon theories. In the next section we pin down a smaller class of categories which correspond to non-degenerate theories of anyons.


\subsection{Modular categories}
In this section we  define modular categories and state a few results that we will use in the next section. As we have seen, braided fusion categories are well suited to describe theories of anyons. These form a big class of categories, some of which are uninteresting from the physical point of view. To distinguish between them we can place braided fusion categories in a spectrum by asking what their symmetric center $Z_2$ is. 

\begin{definition}[Symmetric center]
	If $\cat$ is a monoidal category, the symmetric center $Z_2(\mathcal{C})$ is the full subcategory of $\mathcal{C}$ defined by:
	$$ obj \, Z_2(\mathcal{C}) = \{ X\in \mathcal{C} : c_{X,Y} \circ c_{Y,X} = id_{Y\otimes X} \quad \forall Y \in \mathcal{C} \} $$
\end{definition}
It is easy to see that $\cat$ is symmetric iff $Z_2(\cat)=\cat$.
\begin{definition}[Modular categories]
	A braided fusion category is:
	\begin{itemize}
		\item pre-modular if it is spherical,
		\item non-degenerate if $Z_2(\mathcal{C})$ is trivial (i.e it only contains direct sums of the tensor unit as objects, i.e every simple object is isomorphic to the tensor unit)
		\item modular if it is pre-modular and non-degenerate.
	\end{itemize}
\end{definition}
The two opposite ends of this spectrum are symmetric fusion categories on one side (such that $Z_2(\mathcal{C})=\mathcal{C}$) and modular tensor categories (as defined). 
In the first case, we have only symmetric exchange of quantum systems which means all particles in the theory are either bosons or fermions. Such categories exhibit no topological behaviour. Modular categories are the opposite situation, the theory doesn't contain any bosons or fermions but only non-degenerate anyons (i.e anyons with non-trivial twist). Modular categories are very well-behaved theories as we can assign to them the so called modular $S$-matrix which will contain all the information on fusion rules as well as the braided structure.

\begin{definition}[$S$-matrix]
	Let $\mathcal{C}$ be a spherical braided fusion category and let $I$ be the set of isomorphism classes of simple objects in $\mathcal{C}$. We define $S_{i,j}$ for $i,j \in I$ to be the following:
	\begin{equation}
		S_{i,j} := tr(B_{X_j,X_i} \circ B_{X_i, X_j}) =
		\begin{gathered}
		\begin{tikzpicture}[scale=0.8, decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
		\node (0) at (0,0) {};
		\node (1) at (0, 1) {};
		\node (2) at (0.6,-0.9) {$X_j$};
		\node (3) at (-0.6,-0.9) {$X_i$};
		\draw (-0.5,-0.5)--(0.5, 0.5)--(1)--(-0.5,1.5);
		\draw (0.5,-0.5)--(0)--(-0.5,0.5)--(0.5,1.5);
		\draw [bend right=90, looseness=1.5, postaction=decorate] (-0.5,1.5) to (-0.5,-0.5);
		\draw [bend left=90, looseness=1.5, postaction=decorate] (0.5,1.5) to (0.5,-0.5);
		\end{tikzpicture}
		\end{gathered}
	\end{equation}
\end{definition}
\begin{remark}
	Note that it doesn't matter on which side we take the trace by sphericality.
\end{remark} 
\begin{definition}[$T$-matrix]
	Let $\mathcal{C}$ be a spherical braided fusion category, we define the $T$ matrix (indexed by $I$) given by 
	\begin{equation}
		T_{i,j} := \delta_{i,j} tr(B_{X_i,X_j}) = \delta_{i,j}
		\begin{gathered}
		\begin{tikzpicture}[scale=0.8, decoration={markings,mark=at position 0.5 with {\arrow{>}}}]
		\node (0) at (0,0) {};
		\node (2) at (0.6,-0.9) {$X_j$};
		\node (3) at (-0.6,-0.9) {$X_i$};
		\draw (-0.5,-0.5)--(0.5, 0.5);
		\draw (0.5,-0.5)--(0)--(-0.5,0.5);
		\draw [bend right=90, looseness=1.5, postaction=decorate] (-0.5,0.5) to (-0.5,-0.5);
		\draw [bend left=90, looseness=1.5, postaction=decorate] (0.5,0.5) to (0.5,-0.5);
		\end{tikzpicture}
		\end{gathered}
	\end{equation}	
\end{definition}
\begin{remark}
	Categories of this type are called modular as it can be shown that $S$ and $T$ satisfy the same relations as the generators of the modular group $SL(2,\mathbb{Z})$, so that any modular category induces a representation of $SL(2,\mathbb{Z})$. It is a conjecture that the $S$ ant $T$ matrices determine modular categories up to ribbon equivalence.
\end{remark} 
\begin{definition}[Mueger centralizer]
	If $\mathcal{D}$ is a full (tensor) subcategory of $\mathcal{C}$ can define $C_\cat(D)$ to be the full subcategory such that 
	$$obj(C_\cat(D))=\{X \in obj(\mathcal{C}): B_{X,Y} \circ B_{Y,X} = id_{X \otimes Y}\}$$
\end{definition}
It is easy to check this is indeed a monoidal subcategory and it is replete (i.e closed under isomorphisms) \cite{Mueger02}. Also note that $Z_2(\cat) = C_\cat(\cat)$.
The following result is one of the most important pure category theoretic results on modular categories. We will need it for the discussion on the Drinfeld center.
\begin{theorem}[Mueger decomposition] \label{muegerdec}
	Let $\cat$ be a modular category and $\mathcal{K}$ a semisimple full tensor subcategory, then there is an equivalence of braided fusion categories:
	$$ \cat \simeq \mathcal{K} \boxtimes C_\cat(\mathcal{K}) $$
\end{theorem}
\begin{proof}
	This theorem was proved by Mueger in 2002 \cite{Mueger02}.
\end{proof}
\begin{theorem}
	$\mathcal{C}$ is modular iff the $S$-matrix is invertible.
\end{theorem}
\begin{proof}
	Suppose $\cat$ is not modular, then $Z_2(\cat)$ is non-trivial $\implies$ there is a non-trivial simple object $a$ such that its braiding is the symmetry. Therefore $S_{a,i}=d_a d_i$ for all $i \in I$, but also $S_{1,i}= d_i$ and so the first and $a$th rows of $S$ are proportional $\implies$ $S$ is not invertible.\\
	The other direction is less easy and can be found in \cite{Bakalov00} and \cite{Mueger02}.
\end{proof}
We also state the following result which is proved in \cite{Bakalov00}.
\begin{proposition}
	The modular $S$-matrix diagonalises the $N$-matrix.
\end{proposition}
Therefore the $S$-matrix contain all the information of the fusion rules, and with some algebraic manipulation (which can be found in \cite{Bakalov00}) we obtain the well-known Verlinde formula for the fusion coefficients:
\begin{equation}
	N_{ij}^k = \sum_{r\in I} \frac{S_{ir}S_{jr}S_{kr}}{S_{1r}}
\end{equation}
\begin{remark}
	Given any modular category we can use the Turaev-Viro construction \cite{Balsam12}, which yields a $2+1$ topological quantum field theory. For our purposes we only need to view the modular category as a process theory of anyons in the sense of \cite{Abramsky04} and we won't introduce the $TQFT$ formalism.
\end{remark}
\begin{example}[Fibonacci anyons]
	The category $Fib$ of Fibonacci anyons is one of the most popular examples of modular categories as it have a purely algebraic formulation. Anyons of this type are non-abelian and complete for topological quantum computation \cite{Panangaden11}. We will meet them again in the next chapter.\\
	$Fib$ has only two simple objects: $\tau$ and the vacuum type $1$. The fusion rules are given by:
	$$ 1 \otimes \tau = \tau = \tau \otimes 1$$
	$$ \tau \otimes \tau = 1 \oplus \tau $$ 
	It turns out that those equations together with the hexagon and pentagon constraints completely determine a modular category \cite{Simon16}.
\end{example}


\subsection{The Drinfeld center}
In this section we introduce a general construction that turns braided fusion categories into modular categories, and we show its relationship with the Quantum double construction on a Hopf Algebra introduced in the first chapter.\\
Topological dependencies between objects in fusion categories are captured by the braided structure. Let us fix some definitions before discussing the Drinfeld construction.
\begin{definition}[Half-braiding]
	A half-braiding on some object $X$ in a monoidal category $\cat$ is a natural isomorphism 
	$$ e^X : X \otimes (-) \Rightarrow (-) \otimes X$$
	satisfying the compatibility condition:
	$$e^X_{Y \otimes Z} = (id_Y \otimes e^X_Z) \circ ( e^X_Y \otimes id_Z) $$ 
\end{definition}
\begin{definition}[Drinfeld center]
	The braided (Drinfeld) center of a monoidal category $\mathcal{C}$ is the category $Z(\mathcal{C})$ with objects pairs $(X,e^X)$ where $X \in \mathcal{C}$ and $e^X$ is a half-braiding, and with morphisms given by the morphisms of $\mathcal{C}$ which commute with the half-braiding.
\end{definition}
\begin{definition}[Yetter-Drinfeld modules]
	Let $H$ be a bialgebra, the category $\mathcal{D}_{H}^{lr}$ is the category of left-right Yetter-Drinfeld modules where objects are left $H$-modules which are simultaneously right $H$-comodules satisfying the following compatibility condition:
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0,-0.3) {};
	\node [scale=0.5, squr] (3) at (0,0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (0.5,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.3) {};
	\draw (-0.5,-0.7)--(2)--(1)--(0.5,0.7);
	\draw [bend left] (2) to (3);
	\draw [bend right] (0) to (1);
	\draw (0,-0.7)--(0)--(3)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (-0.3,0.3) {};
	\node [scale=0.5, squr] (3) at (0.3,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (0.3,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.3,-0.5) {};
	\draw (-0.3,-0.7)--(2)--(1)--(0.3,0.7);
	\draw (2) to (3);
	\draw (0) to (1);
	\draw (-0.3,0.7)--(0);
	\draw[bend right] (0) to (0,0);
	\draw[bend left] (0,0) to (3);
	\draw (3)--(0.3,-0.7);
	\end{tikzpicture}
	\end{gathered}	
	\end{equation}
	where the white box denotes the $H$ coaction and the black box defines the right coaction. Morphisms of $\mathcal{D}_{H}^{lr}$ are both $H$-module and $H$-comodule morphisms. Left-left Yetter-Drinfeld modules are defined in the obvious way and form a category $\mathcal{D}_{H}^{ll}$. The compatibility condition then looks like this:
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0,-0.3) {};
	\node [scale=0.5, squr] (3) at (0,0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.5,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.3) {};
	\draw (-0.5,-0.7)--(2)--(1)--(-0.5,0.7);
	\draw (2) to (3);
	\draw (0) to (1);
	\draw (0,-0.7)--(0)--(3)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0,0.3) {};
	\node [scale=0.5, squr] (3) at (0,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.5,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.5) {};
	\draw (-0.5,-0.7)--(2);
	\draw [bend right=90, looseness=3] (2) to (1);
	\draw (1)--(-0.5,0.7);
	\draw [bend left] (2) to (3);
	\draw [bend left] (0) to (1);
	\draw (0,-0.7)--(3)--(0)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
\end{definition}
\begin{proposition}
	Let $\cat$ be a monoidal category, then $Z(\cat)$ is braided monoidal.
\end{proposition}
\begin{proof}	
	It is easy to check that defining the tensor as $(X \otimes Y, e^{X \otimes Y}_Z= (e^X_Z \otimes id_Y) \circ (id_X \otimes e^Y(Z))$
	and the braiding as $e^X_Y$ yields a braided monoidal structure on $Z(\cat)$.
\end{proof}
The following proposition hints to the relationship between the Drinfeld center and the quantum double.
\begin{proposition}
	The Drinfeld center of a spherical fusion category is modular.
	And $dim(Z(\cat)) = dim(\cat)^2$
\end{proposition}
\begin{proof}
	Proof is given by \cite{Mueger02}.
\end{proof}
In general $Z(\cat)$ is not symmetric as we will see, but in the case of $Vect$ the Drinfeld construction is trivial.
\begin{proposition}
	$Z(Vect) \simeq Vect$
\end{proposition}
\begin{proof}
	Using the Mueger decomposition \ref{muegerdec}, note that $Z(Vect)$ is modular and $Vect$ is a full fusion subcategory of $Z(Vect)$, therefore 
	$$Z(Vect) \simeq Vect \boxtimes C_{Z(Vect)}(Vect)$$
	But if $(A, e^A)$ is an object of $C_{Z(Vect)}(Vect)$ then any component $e^A_B$ must be the inverse of the symmetry morphism on $A\otimes B$ $\implies$ it must be the symmetry morphism $\implies$  $C_{Z(Vect)}(Vect)	\simeq Vect$ and so $Z(Vect) \simeq Vect$
	\end{proof} 
Fix a bialgebra $H$ and suppose $ \left( V, \begin{tikzpicture}[scale=0.5, squr/.style={draw,regular polygon,
	regular polygon sides=4,fill=black}]
\node [scale=0.3, squr] (0) at (0,0.4) {};
\draw (0,0)--(0)--(0,0.7);
\draw[bend left] (-0.4,0) to (0);
\end{tikzpicture} \, \right) \,
\in obj(Rep(H))$ and $(V, e_V)$ is in $Z(RepG)$.
Note that $H$ has a natural $H$-module structure given by right multiplication. Consider the component of the half-braiding of $H$ at $V$.
\begin{center}	
	\begin{tikzpicture}
	\node (0) at (0,0) {};
	\node (1) at (-0.7, -0.7) {$H$};
	\node (2) at (0.7, -0.7) {$V$};
	\draw (1)--(0.5,0.5);
	\draw (2)--(0)--(-0.5,0.5);
	\end{tikzpicture}
\end{center}
In the arguments that follow we will use repeatedly the following trick which we state as a Lemma, it exploits the copy of $Vect$ which lives inside any category of representations.
\begin{lemma}\label{lemma}
	For any $W$ object of $Rep(H)$ with white action and $V$ with half braiding.
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (0,0) {};
	\node [scale=0.5,whit] (1) at (-0.2,-0.3) {};
	\node (4) at (-0.7,-0.9) {$H$};
	\node (5) at (-0.2,-0.9) {$W$};
	\node (5) at (0.3,-0.9) {$V$};
	\draw (-0.2,-0.7)--(1)--(0.4,0.7);
	\draw[bend left] (4) to (1);
	\draw (0) to (-0.3,0.7);
	\draw (0) to (0.3,-0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (-0.1,0.3) {};
	\node [scale=0.5,whit] (1) at (0.3,0.5) {};
	\node (4) at (-0.7,-0.9) {$H$};
	\node (5) at (-0.2,-0.9) {$W$};
	\node (5) at (0.3,-0.9) {$V$};
	\draw (-0.2,-0.7)--(1)--(0.4,0.9);
	\draw[bend left] (4) to (1);
	\draw (-0.3,0.9)--(0);
	\draw (0) to (0,0);
	\draw (0,0) to (0.3,-0.7);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
\end{lemma}
\begin{proof}
	Note that 
	$\left( H\otimes W, \,
	\begin{tikzpicture}[scale=0.5, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node[scale=0.5, draw, circle, fill=black] (0) at (0,0) {};
	\draw (0,-0.5)--(0)--(0,0.5);
	\draw [bend left] (-0.5,-0.5) to (0);
	\draw (0.5,-0.5)--(0.5,0.5);
	\end{tikzpicture} \, \right)$
	is in $Rep(H)$ and
	\begin{equation*}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.5, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node[scale=0.5, whit] (0) at (0,0) {};
	\draw (0,-0.5)--(0)--(0,0.5);
	\draw [bend left] (-0.5,-0.5) to (0);
	\end{tikzpicture}
	\end{gathered} : 
	\left( H\otimes W, \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.5]
	\node[scale=0.5, draw, circle, fill=black] (0) at (0,0) {};
	\draw (0,-0.5)--(0)--(0,0.5);
	\draw [bend left] (-0.5,-0.5) to (0);
	\draw (0.5,-0.5)--(0.5,0.5);
	\end{tikzpicture}
	\end{gathered} \, \right)
	\rightarrow 
	\left( W, \, \begin{gathered}
	\begin{tikzpicture}[scale=0.5, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node[scale=0.5, whit] (0) at (0,0) {};
	\draw (0,-0.5)--(0)--(0,0.5);
	\draw [bend left] (-0.5,-0.5) to (0);
	\end{tikzpicture}
	\end{gathered} \,\right)
	\end{equation*} 
	is an intertwiner by the module law.
	Also it is easy to check that the symmetry morphism lifted from $Vect$ 
	$$
	\left( W, \, \begin{gathered}
	\begin{tikzpicture}[scale=0.5]
	\draw (0,-0.5)--(0,0.5);
	\end{tikzpicture}
	\end{gathered} \,\right)
	\otimes V 
	\rightarrow 
	V \otimes \left( W, \, \begin{gathered}
	\begin{tikzpicture}[scale=0.5]
	\draw (0,-0.5)--(0,0.5);
	\end{tikzpicture}
	\end{gathered} \,\right) $$ 
	is an intertwiner. And it follows from $Z(Vect)=Vect$ that it must be the $W$-component (where $W$ has the trivial action) of the half braiding on $V$ as $W$ lives in the copy of $Vect$ in $Rep(H)$.
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Define a right coaction of $H$ on $V$:
\begin{equation}
\begin{gathered}
\begin{tikzpicture}[whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\node[scale=0.5,whit] (0) at (0,0) {};
\node (1) at (0.5, 0.7) {$H$};
\node (2) at (0, -0.7) {$V$};
\draw[bend right] (0) to (0.5,0.5);
\draw (2)--(0)--(0,0.5);
\end{tikzpicture}
\end{gathered}
\, := \,
\begin{gathered}
\begin{tikzpicture}[whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\node (0) at (0,0) {};
\node [scale=0.5, draw, circle, fill=black] (1) at (-0.3,-0.3) {};
\draw (1)--(0.5,0.5);
\draw [bend right] (0.5, -0.5) to (0);
\draw [bend left] (0) to (-0.5,0.5);
\end{tikzpicture}
\end{gathered}			
\end{equation}
Note that, from the bialgebra laws, \counit and \comult (seen as morphisms on the $H$-module $H$) are intertwiners in $Rep(H)$. Therefore by naturality of the half braiding we get:
\begin{equation}
\begin{gathered}
\begin{tikzpicture}[whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\node (0) at (0,0) {};
\node [scale=0.5, draw, circle, fill=black] (1) at (-0.3,-0.3) {};
\node [scale=0.5, draw, circle, fill=white] (2) at (0.2,0.2) {};
\draw (1)--(2);
\draw [bend right] (2) to (0.6,0.5);
\draw [bend left] (2) to (-0.2,0.5);
\draw [bend right] (0.5, -0.5) to (0);
\draw [bend left] (0) to (-0.5,0.5);
\end{tikzpicture}
\end{gathered}
\, = \,
\begin{gathered}
\begin{tikzpicture}[whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\node (0) at (-0.2,0.2) {};
\node (3) at (0.2, -0.2) {};
\node [scale=0.5, draw, circle, fill=black] (1) at (-0.4,-0.4) {};
\node [scale=0.5, draw, circle, fill=white] (2) at (-0.2,-0.2) {};
\draw (1)--(2);
\draw [bend right=50] (2) to (0.6,0.5);
\draw [bend left] (2) to (0,0.5);
\draw [bend right] (0.5, -0.5) to (3);
\draw (3)--(0);
\draw [bend left] (0) to (-0.5,0.5);
\end{tikzpicture}
\end{gathered}
\, = \,	
\begin{gathered}
\begin{tikzpicture}[whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\node (0) at (-0.2,0.2) {};
\node (3) at (0.2, -0.2) {};
\node [scale=0.5, draw, circle, fill=black] (1) at (-0.4,-0.2) {};
\node [scale=0.5, draw, circle, fill=black] (2) at (0,-0.4) {};
\draw (2) to (0.6,0.5);
\draw (1) to (0,0.5);
\draw [bend right] (0.5, -0.5) to (3);
\draw (3)--(0);
\draw [bend left] (0) to (-0.5,0.5);
\end{tikzpicture}
\end{gathered}	
\end{equation}
and
\begin{equation}
\begin{gathered}
\begin{tikzpicture}[whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\node (0) at (0,0) {};
\node [scale=0.5, draw, circle, fill=black] (1) at (-0.3,-0.3) {};
\node [scale=0.5, draw, circle, fill=white] (2) at (0.2,0.2) {};
\draw (1)--(2);
\draw [bend right] (0.5, -0.5) to (0);
\draw [bend left] (0) to (-0.5,0.5);
\end{tikzpicture}
\end{gathered}
\, = \,
\begin{gathered}
\begin{tikzpicture}[whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\node (0) at (0,0) {};
\node [scale=0.5, draw, circle, fill=black] (1) at (-0.4,-0.4) {};
\node [scale=0.5, draw, circle, fill=white] (2) at (-0.2,-0.2) {};
\draw (1)--(2);
\draw (0.5, -0.5)--(-0.5,0.5);
\end{tikzpicture}
\end{gathered}
\, = \,	
\begin{gathered}
\begin{tikzpicture}[whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\draw (0,-0.5) to (0,0.5);
\end{tikzpicture}
\end{gathered}	
\end{equation}
So that the coaction indeed defines a left $H$-comodule.
\begin{claim}
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0,-0.3) {};
	\node [scale=0.5, squr] (3) at (0,0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (0.5,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.3) {};
	\draw (-0.5,-0.7)--(2)--(1)--(0.5,0.7);
	\draw [bend left] (2) to (3);
	\draw [bend right] (0) to (1);
	\draw (0,-0.7)--(0)--(3)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (-0.3,0.3) {};
	\node [scale=0.5, squr] (3) at (0.3,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (0.3,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.3,-0.5) {};
	\draw (-0.3,-0.7)--(2)--(1)--(0.3,0.7);
	\draw (2) to (3);
	\draw (0) to (1);
	\draw (-0.3,0.7)--(0);
	\draw[bend right] (0) to (0,0);
	\draw[bend left] (0,0) to (3);
	\draw (3)--(0.3,-0.7);
	\end{tikzpicture}
	\end{gathered}	
	\end{equation}
\end{claim}
\begin{proof}
	As the braiding is an intertwiner, it commutes with the action of $H$ on $V \otimes H$, therefore:
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (0,-0.3) {};
	\node [scale=0.5, squr](3) at (0,0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (0.5,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (4) at (-0.3,-0.4) {}; 
	\draw (-0.5,-0.7)--(2)--(1)--(0.5,0.7);
	\draw [bend left] (2) to (3);
	\draw [bend right] (4) to (1);
	\draw (0,-0.7)--(0)--(3)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (0,0) {};
	\node [scale=0.5, squr] (3) at (0.3,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.2,-0.2) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.5) {};
	\node [scale=0.5, draw, circle, fill=black] (4) at (-0.2,-0.6) {};
	\draw (-0.5,-0.7)--(2);
	\draw [bend left] (2) to (1);
	\draw (1)--(0.3,0.7);
	\draw (2) to (3);
	\draw (4) to (1);
	\draw[bend left] (0) to (-0.3,0.7);
	\draw[bend left] (0) to (3);
	\draw (3)--(0.3,-0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (0,0) {};
	\node [scale=0.5, squr] (3) at (0.3,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.2,-0.2) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.3,-0.5) {};
	\node [scale=0.5, draw, circle, fill=black] (4) at (-0.6,-0.3) {};
	\draw (-0.3,-0.7)--(2);
	\draw (2)--(1)--(0.3,0.7);
	\draw (2) to (3);
	\draw[bend left] (4) to (1);
	\draw[bend left] (0) to (-0.3,0.7);
	\draw[bend left] (0) to (3);
	\draw (3)--(0.3,-0.7);
	\end{tikzpicture}
	\end{gathered}	
	\end{equation}
	Therefore by Lemma \ref{lemma} and naturality of the braid:
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (0,0) {};
	\node [scale=0.5, squr] (3) at (0.3,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.2,-0.2) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.3,-0.5) {};
	\node [scale=0.5, draw, circle, fill=black] (4) at (-0.6,-0.3) {};
	\draw (-0.3,-0.7)--(2);
	\draw (2)--(1)--(0.3,0.7);
	\draw (2) to (3);
	\draw[bend left] (4) to (1);
	\draw[bend left] (0) to (-0.3,0.7);
	\draw[bend left] (0) to (3);
	\draw (3)--(0.3,-0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (-0.3,0.3) {};
	\node [scale=0.5, squr] (3) at (0.3,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (0.3,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.3,-0.5) {};
	\node [scale=0.5, draw, circle, fill=black] (4) at (-0.5,0.2) {};
	\draw (-0.3,-0.7)--(2)--(1)--(0.3,0.7);
	\draw (2) to (3);
	\draw (4) to (1);
	\draw (-0.3,0.7)--(0);
	\draw[bend right] (0) to (0,0);
	\draw[bend left] (0,0) to (3);
	\draw (3)--(0.3,-0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (-0.3,0.3) {};
	\node [scale=0.5, squr] (3) at (0.3,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (0.3,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.3,-0.5) {};
	\draw (-0.3,-0.7)--(2)--(1)--(0.3,0.7);
	\draw (2) to (3);
	\draw (0) to (1);
	\draw (-0.3,0.7)--(0);
	\draw[bend right] (0) to (0,0);
	\draw[bend left] (0,0) to (3);
	\draw (3)--(0.3,-0.7);
	\end{tikzpicture}
	\end{gathered}	
	\end{equation}
\end{proof}
We have defined a functor $F_1: Z(Rep(H)) \rightarrow \mathcal{D}_H^{lr}$ which is identity on arrows and sends $(V,e_V)$ to the left-right Yetter-Drinfeld module with black $H$ action and white $H$ coaction. To see that it is well defined to say it is identity on arrows (and so faithful) note that if an $H$-module morphism $f$ is in $Z(Rep(H))$ then it commutes with the half-brading, in particular it commutes with the $H$-component of the half-braiding and therefore it commutes with the $H$-coaction as defined.\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Similarly we can define a functor $F_2: Z(Rep(H)) \rightarrow \mathcal{D}_H^{ll}$ by considering the $H$ component of the half braiding on $V$ and defining the following left-coaction:
\begin{equation}
\begin{gathered}
\begin{tikzpicture}[whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\node[scale=0.5,whit] (0) at (0,0) {};
\node (1) at (-0.5, 0.7) {$H$};
\node (2) at (0, -0.7) {$V$};
\draw[bend left] (0) to (-0.5,0.5);
\draw (2)--(0)--(0,0.5);
\end{tikzpicture}
\end{gathered}
\, := \,
\begin{gathered}
\begin{tikzpicture}[whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\node (0) at (0,0) {};
\node [scale=0.5, draw, circle, fill=black] (1) at (0.3,-0.3) {};
\draw (1)--(0)--(-0.5,0.5);
\draw [bend left] (-0.5, -0.5) to (0,0);
\draw [bend right] (0,0) to (0.5,0.5);
\end{tikzpicture}
\end{gathered}			
\end{equation}
\begin{claim}
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0,-0.3) {};
	\node [scale=0.5, squr] (3) at (0,0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.5,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.3) {};
	\draw (-0.5,-0.7)--(2)--(1)--(-0.5,0.7);
	\draw (2) to (3);
	\draw (0) to (1);
	\draw (0,-0.7)--(0)--(3)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0,0.3) {};
	\node [scale=0.5, squr] (3) at (0,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.5,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.5) {};
	\draw (-0.5,-0.7)--(2);
	\draw [bend right=90, looseness=3] (2) to (1);
	\draw (1)--(-0.5,0.7);
	\draw [bend left] (2) to (3);
	\draw [bend left] (0) to (1);
	\draw (0,-0.7)--(3)--(0)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
\end{claim}
\begin{proof}
	The proof is very similar to that of the previous claim. Using the fact that the braid is an intertwiner we obtain
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5] (0) at (0,-0.3) {};
	\node [scale=0.5, squr] (3) at (0,0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.5,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (4) at (0.3,-0.5) {};
	\draw (-0.5,-0.7)--(2)--(1)--(-0.5,0.7);
	\draw (2) to (3);
	\draw (0,-0.7)--(3)--(0,0.7);
	\draw [bend left=10] (0) to (1);
	\draw (4) to (0);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node  (0) at (0,0.3) {};
	\node [scale=0.5, squr] (3) at (0,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (0.2,0) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.4,-0.5) {};
	\node [scale=0.5, draw, circle, fill=black] (4) at (0.5,-0.1) {};
	\draw (-0.5,-0.7)--(2);
	\draw [bend right=90] (2) to (1);
	\draw (1)--(0);
	\draw (4) to (1);
	\draw [bend left] (2) to (3);
	\draw [bend left] (0) to (-0.5,0.7);
	\draw (0,-0.7)--(3)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
	Then using the unit law and the same trick as before we see that
	\begin{equation}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node  (0) at (0,0.3) {};
	\node [scale=0.5, squr] (3) at (0,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (0.5,0) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.4,-0.5) {};
	\node [scale=0.5, draw, circle, fill=black] (4) at (0.3,-0.2) {};
	\draw (-0.5,-0.7)--(2);
	\draw [bend right=90] (2) to (1);
	\draw (1)--(0);
	\draw (4) to (1);
	\draw [bend left] (2) to (3);
	\draw [bend left] (0) to (-0.5,0.7);
	\draw (0,-0.7)--(3)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (0,0.2) {};
	\node [scale=0.5, squr] (3) at (0,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.5,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.5) {};
	\node [scale=0.5, draw, circle, fill=black] (4) at (0.3,0.1) {};
	\draw (-0.5,-0.7)--(2);
	\draw [bend right=90, looseness=3.4] (2) to (1);
	\draw (1)--(-0.5,0.7);
	\draw [bend left] (2) to (3);
	\draw[bend left=20] (0) to (1);
	\draw (4) to (0);
	\draw (0,-0.7)--(3)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
\end{proof}
For the same reasons as for $F_1$, $F_2$ is faithful. To show $F_1$ and $F_2$ are equivalences of categories we still need to show they are full and essentially surjective.
\begin{proposition}
	$F_1$ and $F_2$ are full.
\end{proposition}
\begin{proof}
	Suppose $f$ is a morphism $V \rightarrow W$ in $\mathcal{D}_H^{lr}$, then using the Lemma we see that for any $Z$ in $Rep(H)$ with gray $H$-action:
	\begin{equation}
		\begin{gathered}
		\begin{tikzpicture}[whit/.style={draw,regular polygon,
			regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
			regular polygon sides=4,fill=black}]
		\node (0) at (0,0) {};
		\node [scale=0.5, draw, circle, fill=gray] (f) at (0.4, -0.4) {};
		\node (1) at (0.6, -0.3) {$f$};
		\node (4) at (-0.6,-0.8) {$Z$};
		\node (4) at (0.6,-0.8) {$V$};
		\node (5) at (0,0) {};
		\draw (-0.6, -0.6)--(0.6, 0.6);
		\draw (0.6, -0.6)--(f)--(0)--(-0.6, 0.6);
		\end{tikzpicture}
		\end{gathered}
		\, = \,
		\begin{gathered}
		\begin{tikzpicture}[whit/.style={draw,regular polygon,
			regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
			regular polygon sides=4,fill=black}]
		\node (0) at (0,0) {};
		\node [scale=0.5, draw, circle, fill=gray] (f) at (0.4, -0.4) {};
		\node [scale=0.5,whit, fill=gray] (2) at (-0.3,-0.3) {};
		\node [scale=0.5, draw, circle, fill=black] (3) at (-0.9,-0.5) {};
		\node (1) at (0.6, -0.3) {$f$};
		\draw (-0.6, -0.6)--(2)--(0.6, 0.6);
		\draw (0.6, -0.6)--(f)--(0)--(-0.6, 0.6);
		\draw (3) to (2);
		\end{tikzpicture}
		\end{gathered}
		\, = \,
		\begin{gathered}
		\begin{tikzpicture}[whit/.style={draw,regular polygon,
			regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
			regular polygon sides=4,fill=black}]
		\node (0) at (-0.3,0.3) {};
		\node [scale=0.5, draw, circle, fill=gray] (f) at (0.4, -0.4) {};
		\node [scale=0.5,whit, fill=gray] (2) at (0.3,0.3) {};
		\node [scale=0.5, draw, circle, fill=black] (3) at (-0.6,0.1) {};
		\node (1) at (0.6, -0.3) {$f$};
		\draw (-0.6, -0.6)--(2)--(0.6, 0.6);
		\draw (0.6, -0.6)--(f)--(0)--(-0.6, 0.6);
		\draw[bend left] (3) to (2);
		\end{tikzpicture}
		\end{gathered}
	\end{equation} 
	And by definition of $f$, it commutes with the coaction so that:
\begin{equation}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (-0.3,0.3) {};
	\node [scale=0.5, draw, circle, fill=gray] (f) at (-0.6, 0.6) {};
	\node [scale=0.5,whit, fill=gray] (2) at (0.3,0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (3) at (-0.6,0.1) {};
	\node (1) at (-0.8, 0.45) {$f$};
	\draw (-0.4, -0.4)--(2)--(0.8, 0.8);
	\draw (0.4, -0.4)--(0)--(f)--(-0.8, 0.8);
	\draw[bend left] (3) to (2);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (-0.3,0.3) {};
	\node [scale=0.5, draw, circle, fill=gray] (f) at (-0.6, 0.6) {};
	\node [scale=0.5,whit, fill=gray] (2) at (0.3,0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (3) at (-0.6,0.1) {};
	\node (1) at (-0.8, 0.45) {$f$};
	\draw (-0.4, -0.4)--(2)--(0.8, 0.8);
	\draw (0.4, -0.4)--(0)--(f)--(-0.8, 0.8);
	\draw[bend left] (3) to (2);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node (0) at (0,0) {};
	\node [scale=0.5, draw, circle, fill=gray] (f) at (-0.4, 0.4) {};
	\node (1) at (-0.6, 0.3) {$f$};
	\draw (-0.6, -0.6)--(0.6, 0.6);
	\draw (0.6, -0.6)--(0)--(f)--(-0.6, 0.6);
	\end{tikzpicture}
	\end{gathered}
\end{equation} 
	So $f$ commutes with the half braiding $\implies$ it is a morphism in $Z(Rep(H))$. Therefore $F_1$ is full. And a similar proof applies to $F_2$.	 
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proposition}
	If $H$ is a Hopf algebra, $F_1$ is essentially surjective.
\end{proposition}
\begin{proof}
	To prove this we construct a half braiding for any object $V$ of $\mathcal{D}_H^{lr}$ which yields the coaction of the form [cite equations].\\
	Fix any object $V$ with white right $H$-coaction and for any 
	$\left( W, \begin{tikzpicture}[scale=0.3, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node [scale=0.4,whit, fill=gray] (0) at (0, 0.5) {};
	\draw[bend left] (-0.5,0) to (0);
	\draw (0,0)--(0)--(0,1);
	\end{tikzpicture} \, \right) $
	define
	\begin{equation} \label{defbraid}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node (0) at (0.5,0.5) {};
	\node (v) at (0,-0.3) {$V$};
	\node (w) at (1,-0.3) {$W$};
	\draw (0,0)--(1,1);
	\draw (1,0)--(0)--(0,1);
	\end{tikzpicture}
	\end{gathered}
	\, := \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node[scale=0.4, whit] (0) at (0,-1) {};
	\node[scale=0.4, whit, fill=gray] (1) at (1,-0.8) {};
	\node [scale=0.3,whit] (S) at (0.5,-0.9) {$S$};
	\draw [bend right] (0,0) to (0.5,-0.5);
	\draw [bend left] (0.5,-0.5) to (1);
	\draw (1) to (1,-1.3);
	\draw [bend left] (1,0) to (0.5,-0.5);
	\draw [bend right=20] (0.5,-0.5) to (0);
	\draw (0) to (0,-1.3);
	\draw (0)--(S)--(1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
	(\ref{defbraid}) is an isomorphism as 
	\begin{equation} \label{rightbraid}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node (0) at (0.5,0.5) {};
	\node (v) at (0,-0.3) {$W$};
	\node (w) at (1,-0.3) {$V$};
	\draw (0,0)--(1,1);
	\draw (1,0)--(0)--(0,1);
	\end{tikzpicture}
	\end{gathered}
	\, := \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node[scale=0.5, whit] (0) at (0,0.8) {};
	\node[scale=0.4, whit, fill=gray] (1) at (1,1) {};
	\node (v) at (0,-0.3) {$W$};
	\node (w) at (1,-0.3) {$V$};
	\draw [bend left] (0,0) to (0.5,0.5);
	\draw [bend right] (0.5,0.5) to (1);
	\draw (1) to (1,1.3);
	\draw [bend right] (1,0) to (0.5,0.5);
	\draw [bend left=20] (0.5,0.5) to (0);
	\draw (0) to (0,1.3);
	\draw (0) to (1);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
	is an inverse by the hopf law. It is natural in $W$ as all morphisms are intertwiners (so they commute with the $H$-action on $W$). And it satisfies the compatibility condition by definition of $H$-comodule.
	Clearly setting $W=H$ in (\ref{rightbraid}) with the natural left-multiplication action, and inserting \unit on the left of the tensor yields the $H$-coaction.
\end{proof}
\begin{proposition}
	If $H$ has a skew antipode, $F_2$ is essentially surjective.
\end{proposition}
\begin{proof}
	Define
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node (0) at (0.5,0.5) {};
	\node (v) at (0,-0.3) {$V$};
	\node (w) at (1,-0.3) {$W$};
	\draw (0,0)--(1,1);
	\draw (1,0)--(0)--(0,1);
	\end{tikzpicture}
	\end{gathered}
	\, := \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node[scale=0.4, whit] (0) at (0,0.3) {};
	\node [scale=0.4,whit, fill=gray] (1) at (0,0.9) {};
	\draw [bend left=70, looseness=1.5] (0) to (1);
	\draw (-0.2,0)--(0)--(0.8,1.2);
	\draw (0.8,0)--(1)--(-0.2,1.2);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
	The same argument as the previous proposition applies defining the inverse using the skew antipode $\bar{S}$: 
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node (0) at (0.5,0.5) {};
	\node (v) at (0,-0.3) {$W$};
	\node (w) at (1,-0.3) {$V$};
	\draw (0,0)--(0)--(1,1);
	\draw (1,0)--(0,1);
	\end{tikzpicture}
	\end{gathered}
	\, := \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node[scale=0.4, whit] (0) at (1,0.3) {};
	\node [scale=0.4,whit, fill=gray] (1) at (1,0.9) {};
	\node [scale=0.3,whit] (S) at (0,0.6) {$\bar{S}$};
	\draw [bend left] (0) to (S);
	\draw [bend left] (S) to (1);
	\draw (1.2,0)--(0)--(0,1.2);
	\draw (0,0)--(1)--(1.2,1.2);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
\end{proof}
\begin{corollary}
	If $H$ is a Hopf algebra then $Z(RepH) \simeq \mathcal{D}_H^{lr}$. If $H$ has a skew antipode then $Z(RepH) \simeq \mathcal{D}_H^{ll}$.
\end{corollary}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let us see how the two kinds of Yetter Drinfeld modules interact with one another. For any 
$\left( W, \begin{tikzpicture}[scale=0.3, whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}]
\node [scale=0.4,whit, fill=gray] (0) at (0, 0.5) {};
\draw[bend left] (-0.5,0) to (0);
\draw (0,0)--(0)--(0,1);
\end{tikzpicture} \, \right) $
we have
\begin{equation}
\begin{gathered}
\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
\node (0) at (0.5,0.5) {};
\node (v) at (0,-0.3) {$W$};
\node (w) at (1,-0.3) {$V$};
\draw (0,0)--(1,1);
\draw (1,0)--(0)--(0,1);
\end{tikzpicture}
\end{gathered}
\, := \,
\begin{gathered}
\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
\node[scale=0.5, whit] (0) at (0,0.8) {};
\node [scale=0.4,whit, fill=gray] (1) at (1,1) {};
\draw [bend left] (0,0) to (0.5,0.5);
\draw [bend right] (0.5,0.5) to (1);
\draw (1) to (1,1.3);
\draw [bend right] (1,0) to (0.5,0.5);
\draw [bend left=20] (0.5,0.5) to (0);
\draw (0) to (0,1.3);
\draw (0) to (1);
\end{tikzpicture}
\end{gathered}
\quad;\quad
\begin{gathered}
\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
\node (0) at (0.5,0.5) {};
\node (v) at (0,-0.3) {$V$};
\node (w) at (1,-0.3) {$W$};
\draw (1,0)--(0,1);
\draw (0,0)--(0)--(1,1);
\end{tikzpicture}
\end{gathered}
\, := \,
\begin{gathered}
\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
	regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
\node[scale=0.5, whit] (0) at (0,0.3) {};
\node [scale=0.4,whit, fill=gray] (1) at (0,0.9) {};
\draw [bend left=70, looseness=1.5] (0) to (1);
\draw (0,0)--(0)--(0.8,1.2);
\draw (0.8,0)--(1)--(0,1.2);
\end{tikzpicture}
\end{gathered}
\end{equation}
\begin{claim}
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node (0) at (0.5,0.5) {};
	\node (3) at (0.5,1.5) {};
	\draw (1,0)--(0)--(0,1)-- (3)--(1,2);
	\draw (0,0)--(1,1)--(0,2);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\draw (0.8,0)--(0.8,2);
	\draw (0.1,0)--(0.1,2);
	\end{tikzpicture}
	\end{gathered}
	\quad \iff \quad
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node[scale=0.5, whit] (0) at (0.5,0.5) {};
	\node[scale=0.5, whit] (1) at (0.5,1) {};
	\node[scale=0.5, draw, circle, fill=black] (b) at (0,1.3) {};
	\draw (b) to (0,1.5);
	\draw [bend right=70, looseness=1.5] (0) to (b);
	\draw [bend left] (1) to (b);
	\draw (0.5,0)--(0)--(1)--(0.5,1.5);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node[scale=0.5, draw, circle, fill=black] (b) at (0,1.3) {};
	\draw (b) to (0,1.5);
	\draw (0.5,0)--(0.5,1.5);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
	
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node (0) at (0.5,0.5) {};
	\node (3) at (0.5,1.5) {};
	\draw (1,0)--(0,1)--(1,2);
	\draw (0,0)--(0)--(1,1)--(3)--(0,2);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.6, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\draw (0.8,0)--(0.8,2);
	\draw (0.1,0)--(0.1,2);
	\end{tikzpicture}
	\end{gathered}
	\quad \iff \quad
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node[scale=0.5, whit] (0) at (0.5,0.3) {};
	\node[scale=0.5, whit] (1) at (0.5,1) {};
	\node[scale=0.5, draw, circle, fill=black] (b) at (1,1.3) {};
	\draw (b) to (1,1.5);
	\draw [bend left=80, looseness=1.8] (0) to (0.6,0.6);
	\draw [bend right=50] (0.6,0.6) to (b);
	\draw (1) to (b);
	\draw (0.5,0)--(0)--(1)--(0.5,1.5);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.8, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node[scale=0.5, draw, circle, fill=black] (b) at (1,1.3) {};
	\draw (b) to (1,1.5);
	\draw (0.5,0)--(0.5,1.5);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
\end{claim}
\begin{proof}
	We will only prove the first statement, the second proof is very similar. First note that from the definition and as W is a $H$-module: 
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node (0) at (0.5,0.5) {};
	\node (3) at (0.5,1.5) {};
	\draw (1,0)--(0)--(0,1)-- (3)--(1,2);
	\draw (0,0)--(1,1)--(0,2);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node[scale=0.5, whit] (0) at (0,0.3) {};
	\node[scale=0.5, whit] (1) at (0,0.8) {};
	\node[scale=0.4,whit, fill=gray] (2) at (0.7,0.5) {};
	\node[scale=0.4,whit, fill=gray] (3) at (0,1.5) {};
	\draw (0.7,-0.3)--(0)--(1)--(0.7,1.8);
	\draw (0,-0.3)--(2)--(3)--(0,1.8);
	\draw[bend left=70] (1) to (3);
	\draw (0) to (2);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, black/.style={draw,regular polygon, regular polygon sides=4,fill=black}]
	\node[scale=0.5, whit] (0) at (0.7,0.3) {};
	\node[scale=0.5, whit] (1) at (0.7,0.8) {};
	\node [scale=0.4,whit, fill=gray] (2) at (0,1.5) {};
	\node[scale=0.5, draw, circle, fill=black] (3) at (0.3,1) {};
	\draw (0.7,-0.3)--(0)--(1)--(0.7,1.8);
	\draw (0,-0.3)--(2)--(0,1.8);
	\draw[bend left=70, looseness=1.5] (3) to (2);
	\draw[bend left] (1) to (3);
	\draw[bend right=80, looseness=1.6] (0) to (3);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
	$(\Longleftarrow)$ is straightforward.
	To show $(\implies)$ set $W=H$ with the natural left module structure given by left multiplication, then inserting the unit state \unit on the left of the tensor we obtain the required identity.
\end{proof}
And we say that if $H$ is a hopf algebra with a skew antipode we can make the right hand sides hold imposing:
\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}]
		\node [whit,scale=0.5] (0) at (0,0) {};
		\draw (0,-1)--(0)--(0,1);
		\draw [bend right] (0) to (0.5,1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[scale=0.7, whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node [scale=0.5,whit] (0) at (0,0) {};
	\node [scale=0.3, whit] (S) at (-0.5,0.2) {$\bar{S}$};
	\draw (0,-1)--(0)--(0,1);
	\draw [bend left] (0) to (S);
	\draw (S) to (0.5,1);
	\end{tikzpicture}
	\end{gathered}
\end{equation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proposition}
	If $H$ is a finite-dimensional Hopf Algebra with invertible antipode then left-left Yetter Drinfeld modules are $DH$-modules.
\end{proposition}
\begin{proof}
	Note that defining $DH$ requires the antipode to be invertible (it is used in the definition of the antipode for $DH$). Making use of the antipode and the compatibility condition we obtain:
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0,-0.3) {};
	\node [scale=0.5, squr] (3) at (0,0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.7,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.7,-0.3) {};
	\node [scale=0.3, whit] (S) at (-0.3,0.3) {$S$};
	\draw (-0.7,-0.7)--(2)--(1)--(-0.7,0.7);
	\draw (2) to (3);
	\draw (0) to (1);
	\draw (0,-0.7)--(0)--(3)--(0,0.7);
	\draw [bend right=60] (2) to (S);
	\draw [bend right] (S) to (1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0,0.3) {};
	\node [scale=0.5, squr] (3) at (0,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.5,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.5,-0.5) {};
	\node [scale=0.3, whit] (S) at (0.7,0) {$S$};
	\draw (-0.5,-0.7)--(2);
	\draw [bend right=90, looseness=3] (2) to (1);
	\draw (1)--(-0.5,0.7);
	\draw [bend left] (2) to (3);
	\draw [bend left] (0) to (1);
	\draw (0,-0.7)--(3)--(0)--(0,0.7);
	\draw [bend right=50] (2) to (S);
	\draw [bend right=50] (S) to (1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0,0.3) {};
	\node [scale=0.5, squr] (3) at (0,-0.3) {};
	\draw [bend left] (-0.5,-0.7) to (3);
	\draw [bend right] (-0.5,0.7) to (0);
	\draw (0,-0.7)--(3)--(0)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
	When $H$ is finite dimensional, we can define the action of $DH$ on $V$ as follows (where thick wires carry $DH$ and thin wires carry $H$)
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}]
	\node[scale=0.7, draw, circle] (0) at (0,0) {};
	\node (1) at (-0.7, -0.7) {$DH$};
	\node (2) at (0, -0.7) {$V$};
	\draw[bend right, thick=2] (0) to (-0.5,-0.5);
	\draw (2)--(0)--(0,0.5);
	\end{tikzpicture}
	\end{gathered}
	\, := \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, squr] (0) at (0,0.5) {};
	\node [scale=0.5, whit] (1) at (0,0) {};
	\draw (0,-0.5)--(1)--(0)--(0,0.9);
	\draw [bend left] (-0.5, -0.5) to (0);
	\draw [bend left] (-0.3,-0.5) to (1);
	\end{tikzpicture}
	\end{gathered}			
	\end{equation}
	This action gives $V$ a $DH$-module structure as:
	\begin{equation}
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0.5,-0.3) {};
	\node [scale=0.5, squr] (1) at (0.2,-0.1) {};
	\node [scale=0.5, whit] (2) at (-0.2,0.1) {};
	\node [scale=0.5, squr] (3) at (-0.5,0.3) {};
	\draw [bend right] (0.7,-0.7) to (0);
	\draw (0)--(1)--(2)--(3);
	\draw [bend left] (3) to (-0.7,0.7);
	\draw [bend left] (0.2,-0.7) to (0);
	\draw [bend left] (-0.1,-0.7) to (1);
	\draw [bend left] (-0.5,-0.7) to (2);
	\draw [bend left] (-0.8,-0.7) to (3);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0.5,-0.3) {};
	\node [scale=0.5, whit] (1) at (0.2,-0.1) {};
	\node [scale=0.5, squr] (2) at (-0.2,0.1) {};
	\node [scale=0.5, squr] (3) at (-0.5,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (w) at (-0.1,-0.4) {};
	\node [scale=0.5, draw, circle, fill=black] (b) at (-0.5,-0.4) {};
	\node [scale=0.3,whit] (s) at (-0.5, -0.1) {$S$};
	\draw [bend right] (0.7,-0.7) to (0);
	\draw (0)--(1)--(2)--(3);
	\draw [bend left] (3) to (-0.7,0.7);
	\draw [bend left] (0.2,-0.7) to (0);
	\draw (-0.1,-0.7) to (w);
	\draw (-0.5,-0.7) to (b);
	\draw [bend left] (-0.8,-0.7) to (3);
	\draw[bend right=80] (w) to (s);
	\draw[bend right, looseness=2] (s) to (b);
	\draw[bend left] (b) to (1);
	\draw (w) to (2);
	\draw (w) to (b);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.5, whit] (0) at (0.4,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (1) at (0.2,-0.1) {};
	\node [scale=0.5, draw, circle, fill=black] (2) at (-0.2,0.2) {};
	\node [scale=0.5, squr] (3) at (-0.1,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (w) at (-0.1,-0.4) {};
	\node [scale=0.5, draw, circle, fill=black] (b) at (-0.5,-0.4) {};
	\node [scale=0.3,whit] (s) at (-0.5, -0.1) {$S$};
	\draw [bend right] (0.7,-0.7) to (0);
	\draw (0)--(3);
	\draw (1) to (0);
	\draw (2) to (3);
	\draw [bend left] (3) to (-0.7,0.7);
	\draw [bend right] (0.2,-0.7) to (1);
	\draw (-0.1,-0.7) to (w);
	\draw (-0.5,-0.7) to (b);
	\draw [bend left=60] (-0.8,-0.7) to (2);
	\draw[bend right=80] (w) to (s);
	\draw[bend right, looseness=2] (s) to (b);
	\draw[bend left] (b) to (1);
	\draw (w) to (2);
	\draw (w) to (b);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
	Now it is easy to see that morphisms commute with the $DH$-action iff they commute with the $H$-action and $H$-coaction. So we have defined a fully faithful embedding of $\mathcal{D}_H^{ll}$ into $Rep(DH)$. To see it is essentially surjective note that, given a $DH$-action on $V$, we can recover the $H$-action by plugging the counit in the $H^\star$ component of the $DH$-action and the $H$-coaction by plugging the unit in the $H$-component and bending the $H^\star$ wire up. It remains to check that those indeed define a left-left Yetter-Drinfeld module in all cases, i.e that the compatibility condition is satisfied. And it is indeed the case:
	\begin{equation}
		\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.7, draw, circle] (0) at (0,-0.3) {};
	\node [scale=0.7, draw, circle] (3) at (0,0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.7,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.7,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (b) at (-0.2,-0.1) {};
	\node [scale=0.5, draw, circle, fill=white] (w) at (-0.2,0.1) {};
	\draw (-0.7,-0.7)--(2);
	\draw [bend left] (2) to (1);
	\draw (1)--(-0.7,0.7);
	\draw [bend left] (2) to (3);
	\draw [bend left](0) to (1);
	\draw (0,-0.7)--(0)--(3)--(0,0.7);
	\draw (b)--(0);
	\draw (w)--(3);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.7, draw, circle] (0) at (0,0) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.7,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.7,-0.3) {};
	\draw (-0.7,-0.7)--(2);
	\draw [bend left] (2) to (1);
	\draw (1)--(-0.7,0.7);
	\draw [bend left=50] (2) to (0);
	\draw [bend left=50](0) to (1);
	\draw (0,-0.7)--(0)--(0,0.7);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.7, draw, circle] (0) at (0,0) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.7,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.7,-0.3) {};
	\node [scale=0.5, draw, circle, fill=black] (b) at (0.4,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (w) at (0.4,-0.2) {};
	\node [scale=0.3,whit] (s) at (0.3, 0.05) {$S$};
	\draw (-0.7,-0.7)--(2);
	\draw [bend left] (2) to (1);
	\draw (1)--(-0.7,0.7);
	\draw [bend left=50] (2) to (0);
	\draw [bend left=50](0) to (1);
	\draw (0,-0.7)--(0)--(0,0.7);
	\draw [bend right] (w) to (b);
	\draw [bend left] (w) to (s);
	\draw [bend left] (s) to (b);
	\draw (w) to (2);
	\draw (b) to (1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.7, draw, circle] (0) at (0,0) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.7,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.7,-0.4) {};
	\node [scale=0.5, draw, circle, fill=black] (b) at (-0.4,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (w) at (-0.4,-0.2) {};
	\node [scale=0.3,whit] (s) at (0.3, 0.05) {$S$};
	\draw (-0.7,-0.7)--(2);
	\draw [bend left] (w) to (b);
	\draw (1)--(-0.7,0.7);
	\draw [bend right=90, looseness=5] (2) to (1);
	\draw [bend left=50] (w) to (0);
	\draw [bend left=50](0) to (b);
	\draw (0,-0.7)--(0)--(0,0.7);
	\draw [bend right] (w) to (s);
	\draw [bend right] (s) to (b);
	\draw (w) to (2);
	\draw (b) to (1);
	\end{tikzpicture}
	\end{gathered}
	\, = \,
	\begin{gathered}
	\begin{tikzpicture}[whit/.style={draw,regular polygon,
		regular polygon sides=4,fill=white}, squr/.style={draw,regular polygon,
		regular polygon sides=4,fill=black}]
	\node [scale=0.7, draw, circle] (0) at (0,-0.15) {};
	\node [scale=0.7, draw, circle] (3) at (0,0.15) {};
	\node [scale=0.5, draw, circle, fill=black] (1) at (-0.7,0.5) {};
	\node [scale=0.5, draw, circle, fill=white] (2) at (-0.7,-0.5) {};
	\node [scale=0.5, draw, circle, fill=black] (b) at (-0.2,0.3) {};
	\node [scale=0.5, draw, circle, fill=white] (w) at (-0.2,-0.3) {};
	\draw (-0.7,-0.7)--(2);
	\draw [bend right=90, looseness=4] (2) to (1);
	\draw (1)--(-0.7,0.7);
	\draw [bend left] (2) to (0);
	\draw [bend left] (3) to (1);
	\draw (0,-0.7)--(0)--(3)--(0,0.7);
	\draw (b)--(3);
	\draw (w)--(0);
	\end{tikzpicture}
	\end{gathered}
	\end{equation}
\end{proof}
\begin{corollary}
	If $H$ is a finite dimensional Hopf algebra with invertible antipode $Z(RepH) \simeq RepDH$
\end{corollary}
We have found many equivalent ways of constructing non-degenerate theories of anyons. In the next section we will use the simplest examples induced by groups, justified by the following proposition
\begin{proposition}
	If $G$ is a finite non-abelian group then $Rep(D(G))$ is modular.
\end{proposition}
\begin{proof}
	A direct proof is given in the third chapter of \cite{Bakalov00}. But this also follows from the fact that $Z(Rep(G))$ is modular.
\end{proof}

\bibliographystyle{unsrt}
\bibliography{refs}
\end{document}
